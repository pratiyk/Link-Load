from typing import List, Dict, Any, Optional
from sqlalchemy.orm import Session
from datetime import datetime
from app.models.vulnerability_models import VulnerabilityData, VulnerabilityMitigation, ThreatIntelData
from app.services.intelligence_sources.base_intel import BaseIntelligence
import logging

logger = logging.getLogger(__name__)

from sqlalchemy import inspect

class VulnerabilityProcessor:
    """Process and enrich vulnerability data"""
    
    def __init__(self, db: Session, intel_sources: Optional[List[BaseIntelligence]] = None):
        self.db = db
        self.intel_sources = intel_sources or []

    def _get_attr_value(self, obj: Any, attr: str) -> Any:
        """Safely get attribute value from SQLAlchemy object"""
        if hasattr(obj, '__table__'):
            return getattr(inspect(obj).attrs, attr).value
        return getattr(obj, attr)

    async def process_vulnerability(self, vulnerability_data: Dict[str, Any], asset_id: int) -> VulnerabilityData:
        """Process a single vulnerability and store it in the database"""
        try:
            # Create vulnerability record
            vuln = VulnerabilityData(
                source=vulnerability_data["source"],
                title=vulnerability_data["title"],
                description=vulnerability_data.get("description"),
                severity=vulnerability_data["severity"],
                cvss_score=vulnerability_data.get("cvss_score"),
                cvss_vector=vulnerability_data.get("cvss_vector"),
                raw_data=vulnerability_data.get("raw_data"),
                asset_id=asset_id
            )
            self.db.add(vuln)
            self.db.flush()  # Get ID without committing

            # Process threat intelligence
            await self._process_threat_intel(vuln)

            # Generate mitigations
            await self._generate_mitigations(vuln)

            self.db.commit()
            return vuln

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error processing vulnerability: {e}")
            raise

    async def _process_threat_intel(self, vulnerability: VulnerabilityData) -> None:
        """Enrich vulnerability with threat intelligence data"""
        for intel_source in self.intel_sources:
            try:
                title = self._get_attr_value(vulnerability, 'title')
                description = self._get_attr_value(vulnerability, 'description')
                
                intel_data = await intel_source.get_intel(
                    title=str(title),
                    description=str(description) if description else None
                )
                
                if intel_data:
                    threat_intel = ThreatIntelData(
                        vulnerability_id=self._get_attr_value(vulnerability, 'id'),
                        source=intel_source.name,
                        threat_type=intel_data.get("threat_type"),
                        confidence_score=intel_data.get("confidence"),
                        last_seen=intel_data.get("last_seen"),
                        raw_data=intel_data.get("raw_data")
                    )
                    self.db.add(threat_intel)

            except Exception as e:
                logger.error(f"Error processing threat intel from {intel_source.name}: {e}")

    async def _generate_mitigations(self, vulnerability: VulnerabilityData) -> None:
        """Generate mitigation recommendations"""
        try:
            # Basic mitigation based on vulnerability type
            # This can be enhanced with ML-based recommendations
            mitigation = VulnerabilityMitigation(
                vulnerability_id=vulnerability.id,
                recommendation=f"Patch the vulnerability: {vulnerability.title}",
                priority=self._calculate_priority(vulnerability),
                estimated_effort="Medium"  # This can be ML-predicted
            )
            self.db.add(mitigation)

        except Exception as e:
            logger.error(f"Error generating mitigations: {e}")

    def _calculate_priority(self, vulnerability: VulnerabilityData) -> int:
        """Calculate priority based on severity and CVSS score"""
        cvss_score = self._get_attr_value(vulnerability, 'cvss_score')
        severity = self._get_attr_value(vulnerability, 'severity')
        
        if cvss_score is None:
            return min(5, max(1, int(float(severity) * 5)))
        
        cvss_score = float(cvss_score)
        if cvss_score >= 9.0:
            return 5
        elif cvss_score >= 7.0:
            return 4
        elif cvss_score >= 5.0:
            return 3
        elif cvss_score >= 3.0:
            return 2
        else:
            return 1