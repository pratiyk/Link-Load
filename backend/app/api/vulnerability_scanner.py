import asyncio
import logging
from uuid import uuid4

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from pydantic import BaseModel, Field
from typing import List, Optional
from app.database import get_db
from app.services.scanners.basic_scanner import BasicVulnerabilityScanner
from app.services.intelligence_sources.nvd_source import NVDIntelligenceSource
from app.services.processors.vulnerability_processor import VulnerabilityProcessor
from app.core.security import get_current_user
from app.utils.vulnerability_sources import query_osv, query_nvd
import os

router = APIRouter()
logger = logging.getLogger(__name__)

NVD_API_KEY = os.getenv("NVD_API_KEY")

class ScanInput(BaseModel):
    target: str
    scan_type: str = "basic"
    options: dict = {}

class ScanResponse(BaseModel):
    scan_id: str
    message: str


class PackageScanRequest(BaseModel):
    name: str = Field(..., min_length=1, max_length=200)
    ecosystem: str = Field(..., min_length=1, max_length=120)
    version: Optional[str] = Field(default=None, max_length=100)
    sources: Optional[List[str]] = Field(default_factory=lambda: ["osv", "nvd"])


class PackageVulnerability(BaseModel):
    id: str
    package: str
    ecosystem: str
    severity: float = Field(..., ge=0.0)
    summary: Optional[str] = None
    affected: Optional[str] = None
    source: str
    references: List[str] = Field(default_factory=list)


class PackageScanResponse(BaseModel):
    results: List[PackageVulnerability]

@router.post("/scan", response_model=ScanResponse)
async def start_vulnerability_scan(
    input: ScanInput,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    try:
        # Initialize scanner and intelligence sources
        scanner = BasicVulnerabilityScanner()
        nvd_source = NVDIntelligenceSource()
        processor = VulnerabilityProcessor(db, intel_sources=[nvd_source])

        # Start scan
        scan_id = await scanner.start_scan(input.target, input.options)
        
        # Process results
        raw_results = await scanner.get_scan_results(scan_id)
        normalized_results = await scanner.normalize_results(raw_results)
        
        # Process each finding
        for result in normalized_results:
            await processor.process_vulnerability(result, current_user.id)
        
        return {
            "scan_id": scan_id,
            "message": "Scan completed successfully"
        }
        
    except Exception as e:
        logger.error(f"Error during vulnerability scan: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Error during vulnerability scan: {str(e)}"
        )


@router.post("/packages/scan", response_model=PackageScanResponse)
async def scan_package_vulnerabilities(
    request: PackageScanRequest,
    current_user = Depends(get_current_user)
):
    try:
        requested_sources = {source.lower() for source in (request.sources or ["osv", "nvd"])}

        tasks: List[asyncio.Future] = []
        if "osv" in requested_sources:
            tasks.append(asyncio.to_thread(query_osv, request.name, request.ecosystem, request.version))
        if "nvd" in requested_sources:
            tasks.append(asyncio.to_thread(query_nvd, request.name))

        aggregated_results: List[dict] = []
        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            for result in results:
                if isinstance(result, Exception):
                    logger.warning("Package scan source failed: %s", result)
                    continue
                aggregated_results.extend(result)

        normalized: List[PackageVulnerability] = []
        for entry in aggregated_results:
            severity_raw = entry.get("severity_score") or 0.0
            try:
                severity_score = float(severity_raw)
            except (TypeError, ValueError):
                severity_score = 0.0

            vuln_id = entry.get("id") or f"pkg-{uuid4().hex[:10]}"

            normalized.append(PackageVulnerability(
                id=vuln_id,
                package=request.name,
                ecosystem=request.ecosystem,
                severity=severity_score,
                summary=entry.get("summary"),
                affected=entry.get("affected"),
                source=entry.get("source", "unknown"),
                references=entry.get("references") or []
            ))

        normalized.sort(key=lambda item: item.severity, reverse=True)

        return PackageScanResponse(results=normalized)
    except Exception as exc:
        logger.error("Failed package vulnerability scan: %s", exc, exc_info=True)
        raise HTTPException(status_code=500, detail="Failed to scan package vulnerabilities")
